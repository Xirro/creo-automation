<#
postinstall-config.ps1

Interactive post-install helper to create `app/config/database.local.js`
so secrets are not stored in the repo. Meant to be run once by an admin
after installation or invoked from the installer as a post-install action.

The script will prompt for DB host/port/name/user/password and whether to
enable SSL and will write a JS module `app/config/database.local.js` that
will be used by the app at runtime.
#>

param(
  [string]$InstallDir = "$(Split-Path -Parent $MyInvocation.MyCommand.Definition)\..",
  [string]$Host,
  [int]$Port,
  [string]$Name,
  [string]$User,
  [string]$Password,
  [switch]$Ssl,
  [string]$IniPath,
  [string]$ServiceAccount
)

function Read-SecureStringAsPlain {
    param([string]$prompt)
    $sec = Read-Host -AsSecureString $prompt
    return [System.Runtime.InteropServices.Marshal]::PtrToStringAuto([System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($sec))
}


Write-Host "Post-install DB configuration helper"
Write-Host "InstallDir: $InstallDir"

# If parameters provided, use them (non-interactive). Otherwise prompt interactively.
if ($IniPath -and (Test-Path $IniPath)) {
  Write-Host "Reading INI values from: $IniPath"
  $ini = Get-Content -Raw -Path $IniPath -ErrorAction SilentlyContinue
  if ($ini) {
    # Simple parser for [DB] section
    $inDb = $false
    foreach ($line in $ini -split "\r?\n") {
      $t = $line.Trim()
      if ($t -match '^\[DB\]') { $inDb = $true; continue }
      if ($inDb -and $t -match '^\[') { break }
      if ($inDb -and $t -match '^(.*?)=(.*)$') {
        $k = $matches[1].Trim()
        $v = $matches[2].Trim()
        switch ($k.ToLower()) {
          'host' { if (-not $Host) { $Host = $v } }
          'port' { if (-not $Port) { $Port = [int]$v } }
          'name' { if (-not $Name) { $Name = $v } }
          'user' { if (-not $User) { $User = $v } }
          'pass' { if (-not $Password) { $Password = $v } }
          'ssl' { if (-not $PSBoundParameters.ContainsKey('Ssl')) { if ($v -eq '1') { $Ssl = $true } } }
          'serviceaccount' { if (-not $ServiceAccount) { $ServiceAccount = $v } }
        }
      }
    }
  }
}

if ($Host) { $dbHost = $Host } else { $dbHost = Read-Host "Database host (e.g. db.example.com or localhost)" }
if ($Port) { $dbPort = $Port } else { $dbPort = Read-Host "Database port (default 3306)"; if (-not $dbPort) { $dbPort = 3306 } }
if ($Name) { $dbName = $Name } else { $dbName = Read-Host "Database name (default: saidb)"; if (-not $dbName) { $dbName = 'saidb' } }
if ($User) { $dbUser = $User } else { $dbUser = Read-Host "Database user (e.g. doadmin)" }
if ($Password) { $dbPass = $Password } else { $dbPass = Read-SecureStringAsPlain "Database password" }

if ($PSBoundParameters.ContainsKey('Ssl')) { $useSsl = $Ssl.IsPresent } else { $useSsl = Read-Host "Use SSL for DB connection? (y/N)"; $useSsl = $useSsl -and $useSsl.ToLower().StartsWith('y') }

$localPath = Join-Path $InstallDir 'app\config\database.local.js'

$content = @"
// This file is generated by scripts/postinstall-config.ps1
module.exports = {
  connection: {
    host: '${dbHost}',
    port: ${dbPort},
    user: '${dbUser}',
    // password intentionally omitted; stored securely in db_pass.enc when available
    database: '${dbName}',
    dialect: 'mysql',
    logging: false,
    ssl: ${($useSsl -eq $true).ToString().ToLower()},
    dialectOptions: {
      ssl: ${($useSsl -eq $true).ToString().ToLower()} ? { ssl: true, cert: require('fs').readFileSync('app/config/ca-certificate.crt') } : undefined
    }
  },
  database: '${dbName}'
};
"@

# Ensure target dir exists
$dir = Split-Path $localPath
if (-not (Test-Path $dir)) { New-Item -ItemType Directory -Path $dir -Force | Out-Null }

Write-Host "Writing local DB config to $localPath"
Set-Content -Path $localPath -Value $content -Encoding UTF8
Write-Host "Wrote local config. File permissions: locking the file to current user..."

try {
    $acl = Get-Acl $localPath
    $me = [System.Security.Principal.NtAccount]::new($env:USERNAME)
    $rule = New-Object System.Security.AccessControl.FileSystemAccessRule($me, 'FullControl', 'Allow')
    $acl.SetAccessRuleProtection($true, $false)
    $acl.SetAccessRule($rule)
    Set-Acl -Path $localPath -AclObject $acl
    Write-Host "Permissions set."
} catch {
    Write-Warning "Failed to set permissions: $_"
}

Write-Host "Post-install configuration complete. You can now start the service or run the app."

# Attempt a live DB connection test using the bundled Node script if present
try {
  $nodeExe = Join-Path $InstallDir 'node\node.exe'
  if (-not (Test-Path $nodeExe)) {
    # fallback to system node
    $nodeExe = 'node'
  }

  $checkScript = Join-Path $InstallDir 'installer\check-db-conn.js'
  if (Test-Path $checkScript) {
    Write-Host "Attempting DB auth/SSL check using $checkScript"
    $args = @()
    $args += '--host'; $args += $dbHost
    $args += '--port'; $args += [string]$dbPort
    $args += '--user'; $args += $dbUser
    $args += '--password'; $args += $dbPass
    $args += '--name'; $args += $dbName
    if ($useSsl) {
      $args += '--ssl'; $args += '1'
      $ca = Join-Path $InstallDir 'app\config\ca-certificate.crt'
      if (Test-Path $ca) { $args += '--ca'; $args += $ca }
    } else {
      $args += '--ssl'; $args += '0'
    }

    $psi = New-Object System.Diagnostics.ProcessStartInfo
    $psi.FileName = $nodeExe
    $psi.Arguments = [string]::Join(' ', ($args | ForEach-Object { '"' + ($_ -replace '"','\"') + '"' }))
    $psi.RedirectStandardOutput = $true
    $psi.RedirectStandardError = $true
    $psi.UseShellExecute = $false
    $proc = New-Object System.Diagnostics.Process
    $proc.StartInfo = $psi
    $proc.Start() | Out-Null
    $stdOut = $proc.StandardOutput.ReadToEnd()
    $stdErr = $proc.StandardError.ReadToEnd()
    $proc.WaitForExit(10000) | Out-Null
    $exit = $proc.ExitCode

    if ($exit -eq 0 -or $stdOut -match 'SUCCESS') {
      Write-Host "DB connection check: SUCCESS"
    } else {
      Write-Warning "DB connection check failed (exit=$exit). Output: $stdOut $stdErr"
    }
  } else {
    Write-Host "DB connection checker script not found at $checkScript; skipping live check."
  }
} catch {
  Write-Warning "DB connection check encountered an error: $_"
}

# Store password encrypted using DPAPI (LocalMachine) so services can read it without plaintext in repo
try {
  $encPath = Join-Path $InstallDir 'app\config\db_pass.enc'
  if ($dbPass) {
    $bytes = [System.Text.Encoding]::UTF8.GetBytes($dbPass)
    $protected = [System.Security.Cryptography.ProtectedData]::Protect($bytes, $null, [System.Security.Cryptography.DataProtectionScope]::LocalMachine)
    $b64 = [System.Convert]::ToBase64String($protected)
  Set-Content -Path $encPath -Value $b64 -Encoding ASCII
  Write-Host "Wrote encrypted DB password to $encPath"
  # Harden ACLs: allow only Administrators, SYSTEM, and optionally the service account to read the file
  try {
    $encAcl = New-Object System.Security.AccessControl.FileSecurity
    $encAcl.SetAccessRuleProtection($true, $false)
    # Administrators
    $admins = New-Object System.Security.Principal.NTAccount('Administrators')
    $ruleAdmin = New-Object System.Security.AccessControl.FileSystemAccessRule($admins, 'ReadAndExecute', 'ContainerInherit,ObjectInherit', 'None', 'Allow')
    $encAcl.AddAccessRule($ruleAdmin)
    # SYSTEM
    $system = New-Object System.Security.Principal.NTAccount('SYSTEM')
    $ruleSys = New-Object System.Security.AccessControl.FileSystemAccessRule($system, 'ReadAndExecute', 'ContainerInherit,ObjectInherit', 'None', 'Allow')
    $encAcl.AddAccessRule($ruleSys)
    # Optional service account (if provided)
    if ($ServiceAccount) {
      try {
        $svc = New-Object System.Security.Principal.NTAccount($ServiceAccount)
        $ruleSvc = New-Object System.Security.AccessControl.FileSystemAccessRule($svc, 'Read', 'ContainerInherit,ObjectInherit', 'None', 'Allow')
        $encAcl.AddAccessRule($ruleSvc)
      } catch {
        Write-Warning "Failed to add service account ACL for $ServiceAccount: $_"
      }
    }
    Set-Acl -Path $encPath -AclObject $encAcl
    Write-Host "Hardened ACLs on $encPath"
  } catch {
    Write-Warning "Failed to set hardened ACLs on $encPath: $_"
  }
  } else {
    Write-Host "No password provided; skipping encrypted store write."
  }
} catch {
  Write-Warning "Failed to write encrypted DB password: $_"
}
